package cat.ella.kissui;

import cat.ella.kissui.component.Component;
import cat.ella.kissui.component.Drawn;
import cat.ella.kissui.render.Renderer;
import cat.ella.kissui.render.Window;
import cat.ella.kissui.unit.Vector2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class KissUI {
    public Window window = null;
    public Logger LOGGER = LogManager.getLogger("KISSUI/");
    public final Renderer renderer;
    public final Component[] components;
    public Vector2 size = Vector2.Constants.of(0, 0);
    public Drawn main;
    public boolean needsRedraw = true; // Track if redraw is needed
    private Vector2 minSize = Vector2.Constants.of(100, 100); // Default minimum size
    private Vector2 maxSize = Vector2.Constants.of(-1, -1);   // Default no max size

    public KissUI(Component[] components, Renderer renderer) {
        this.components = components;
        this.renderer = renderer;
        this.main = new Drawn(components, Vector2.Constants.of(0, 0), Vector2.Constants.of(0, 0), Vector2.Constants.of(0, 0), false);
        renderer.init();
    }

    public void resize(Float newHeight, Float newWidth) {
        this.resize(newHeight, newWidth, false);
    }

    public void resize(Float newHeight, Float newWidth, boolean force) {
        if (newWidth == 0f || newHeight == 0f) {
            LOGGER.error("Cannot resize to zero size: " + newWidth + "x" + newHeight);
            return;
        }

        // Check if same size and not forced
        if (!force && newWidth == size.x() && newHeight == size.y()) {
            LOGGER.warn("Resizing to the same size. Ignoring.");
            return;
        }

        // Apply size constraints
        float constrainedWidth = newWidth;
        float constrainedHeight = newHeight;

        // Minimum size constraint
        if (minSize != null) {
            constrainedWidth = Math.max(newWidth, minSize.x());
            constrainedHeight = Math.max(newHeight, minSize.y());
        }

        // Maximum size constraint
        if (maxSize != null && maxSize.x() > 0 && maxSize.y() > 0) {
            constrainedWidth = Math.min(constrainedWidth, maxSize.x());
            constrainedHeight = Math.min(constrainedHeight, maxSize.y());
        }

        // Apply aspect ratio (placeholder - implement your aspect ratio logic)
        // float aspectRatio = ...;
        // if (constrainedWidth / constrainedHeight != aspectRatio) {
        //     // Adjust to maintain aspect ratio
        // }

        if (constrainedWidth != newWidth || constrainedHeight != newHeight) {
            LOGGER.warn("Constrained size: " + constrainedWidth + "x" + constrainedHeight);
        }

        this.size = Vector2.Constants.of(constrainedWidth, constrainedHeight);
        main.setSize(size);
        needsRedraw = true; // Mark for redraw after resize
    }

    public void render() {
        if (window == null || !needsRedraw) return;

        window.preRender();
        renderer.beginFrame(size.x(), size.y(), 1.0f);
        main.render(renderer); // Actual rendering call
        renderer.endFrame();
        window.postRender();

        needsRedraw = false; // Reset redraw flag
    }

    public void cleanup() {
        renderer.cleanup();
    }

    // === Added missing functionality ===

    public void setMinimumSize(float width, float height) {
        this.minSize = Vector2.Constants.of(width, height);
    }

    public void setMaximumSize(float width, float height) {
        this.maxSize = Vector2.Constants.of(width, height);
    }

    public void requestRedraw() {
        this.needsRedraw = true;
    }

    public void focus(Component component) {
        // Implement focus logic
        needsRedraw = true;
    }

    public void unfocus() {
        // Implement unfocus logic
        needsRedraw = true;
    }
}